{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-bdd295b632c667cdd2f935aea815a403cb40f52d",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EduCertificate.sol": "project/contracts/EduCertificate.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EduCertificate.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract EduCertificate {\r\n    address public admin;\r\n\r\n    struct Certificate {\r\n        uint256 certId;\r\n        address issuer;\r\n        bytes32 certHash;\r\n        string certificateIdString; // e.g. \"CERT-1234...\"\r\n        string studentName;\r\n        string courseName;\r\n        string courseCode;\r\n        string trainingType;\r\n        string duration;\r\n        string result;\r\n        string issuerName;\r\n        string issuerWebsite;\r\n        string issuerContact;\r\n        string fileUrl;\r\n        string fileType;\r\n        uint256 issuedAt;\r\n        bool revoked;\r\n        string revokeTxHash;\r\n    }\r\n\r\n    struct Officer {\r\n        string name;\r\n        address officerAddress;\r\n        uint256 addedAt;\r\n        bool isActive;\r\n    }\r\n\r\n    mapping(uint256 => Certificate) private certificates;\r\n    mapping(address => Officer) public officers;\r\n    address[] public officerList;\r\n    uint256[] public allCertIds;\r\n    uint256 public nextCertId = 1;\r\n\r\n    event OfficerAdded(address officer, string name);\r\n    event OfficerRemoved(address officer);\r\n\r\n    event CertificateIssued(\r\n        uint256 indexed certId,\r\n        address indexed issuer,\r\n        bytes32 certHash\r\n    );\r\n\r\n    event CertificateUpdated(\r\n        uint256 indexed certId,\r\n        bytes32 newHash\r\n    );\r\n\r\n    event CertificateRevoked(uint256 indexed certId);\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOfficerOrAdmin() {\r\n        require(\r\n            msg.sender == admin || officers[msg.sender].isActive,\r\n            \"Not authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOfCert(uint256 certId) {\r\n        require(\r\n            certificates[certId].issuer == msg.sender ||\r\n                msg.sender == admin,\r\n            \"Not cert owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin) {\r\n        admin = _admin;\r\n    }\r\n\r\n    function addOfficer(address officer, string memory name) external onlyAdmin {\r\n        require(!officers[officer].isActive, \"Already an active officer\");\r\n        \r\n        // If officer was previously added but inactive, just reactivate and update name\r\n        // Otherwise, add new\r\n        if (officers[officer].addedAt != 0) {\r\n            officers[officer].isActive = true;\r\n            officers[officer].name = name;\r\n             // Check if already in list to avoid duplicates (though remove doesn't fully remove from array for gas reasons usually, logic here depends on implementation)\r\n             // Simple approach: just update state. Assuming if inactive, they are still in array? \r\n             // Let's check remove logic.\r\n             \r\n             // If we rely on isActive for auth, we just set true.\r\n             // But we need to ensure they are in officerList if not already?\r\n             // To simplify: if re-adding, we don't push to array if already there. \r\n             // BUT, iterating array to check existence is expensive.\r\n             // Given typical low count of officers, we might just duplicate in logic or handle array better.\r\n             // Let's assume strict add/remove for list management.\r\n        } else {\r\n             officers[officer] = Officer({\r\n                name: name,\r\n                officerAddress: officer,\r\n                addedAt: block.timestamp,\r\n                isActive: true\r\n            });\r\n            officerList.push(officer);\r\n        }\r\n\r\n        emit OfficerAdded(officer, name);\r\n    }\r\n\r\n    function removeOfficer(address officer) external onlyAdmin {\r\n        require(officers[officer].isActive, \"Not an active officer\");\r\n        officers[officer].isActive = false;\r\n        \r\n        // We keep them in the array but marked inactive in mapping.\r\n        // Or we can remove from array.\r\n        // For simple iteration in frontend, removing from array is cleaner.\r\n        for (uint i = 0; i < officerList.length; i++) {\r\n            if (officerList[i] == officer) {\r\n                officerList[i] = officerList[officerList.length - 1];\r\n                officerList.pop();\r\n                break;\r\n            }\r\n        }\r\n        \r\n        emit OfficerRemoved(officer);\r\n    }\r\n\r\n    function getOfficers() external view returns (Officer[] memory) {\r\n        Officer[] memory activeOfficers = new Officer[](officerList.length);\r\n        for (uint i = 0; i < officerList.length; i++) {\r\n            activeOfficers[i] = officers[officerList[i]];\r\n        }\r\n        return activeOfficers;\r\n    }\r\n\r\n    struct IssueData {\r\n        bytes32 certHash;\r\n        string certificateIdString;\r\n        string studentName;\r\n        string courseName;\r\n        string courseCode;\r\n        string trainingType;\r\n        string duration;\r\n        string result;\r\n        string issuerName;\r\n        string issuerWebsite;\r\n        string issuerContact;\r\n        string fileUrl;\r\n        string fileType;\r\n    }\r\n\r\n    function issueCertificate(IssueData calldata data)\r\n        external\r\n        onlyOfficerOrAdmin\r\n        returns (uint256)\r\n    {\r\n        uint256 certId = nextCertId;\r\n\r\n        certificates[certId] = Certificate({\r\n            certId: certId,\r\n            issuer: msg.sender,\r\n            certHash: data.certHash,\r\n            certificateIdString: data.certificateIdString,\r\n            studentName: data.studentName,\r\n            courseName: data.courseName,\r\n            courseCode: data.courseCode,\r\n            trainingType: data.trainingType,\r\n            duration: data.duration,\r\n            result: data.result,\r\n            issuerName: data.issuerName,\r\n            issuerWebsite: data.issuerWebsite,\r\n            issuerContact: data.issuerContact,\r\n            fileUrl: data.fileUrl,\r\n            fileType: data.fileType,\r\n            issuedAt: block.timestamp,\r\n            revoked: false,\r\n            revokeTxHash: \"\"\r\n        });\r\n\r\n        allCertIds.push(certId);\r\n        nextCertId++;\r\n\r\n        emit CertificateIssued(certId, msg.sender, data.certHash);\r\n        return certId;\r\n    }\r\n\r\n    function revokeCertificate(uint256 certId, string memory revokeTxHash)\r\n        external\r\n        onlyOwnerOfCert(certId)\r\n    {\r\n        require(!certificates[certId].revoked, \"Already revoked\");\r\n        certificates[certId].revoked = true;\r\n        certificates[certId].revokeTxHash = revokeTxHash;\r\n        emit CertificateRevoked(certId);\r\n    }\r\n\r\n    function verifyCertificate(uint256 certId, bytes32 hashToVerify)\r\n        external\r\n        view\r\n        returns (bool valid, bool revoked, Certificate memory certDetails)\r\n    {\r\n        Certificate memory cert = certificates[certId];\r\n\r\n        if (cert.certId == 0) {\r\n            return (false, false, cert);\r\n        }\r\n\r\n        valid = cert.certHash == hashToVerify;\r\n        revoked = cert.revoked;\r\n        certDetails = cert;\r\n    }\r\n\r\n    function getCertificate(uint256 certId)\r\n        external\r\n        view\r\n        returns (Certificate memory)\r\n    {\r\n        return certificates[certId];\r\n    }\r\n    \r\n    function getAllCertificates() external view returns (Certificate[] memory) {\r\n        Certificate[] memory allCerts = new Certificate[](allCertIds.length);\r\n        for (uint i = 0; i < allCertIds.length; i++) {\r\n            allCerts[i] = certificates[allCertIds[i]];\r\n        }\r\n        return allCerts;\r\n    }\r\n}\r\n"
      }
    }
  }
}